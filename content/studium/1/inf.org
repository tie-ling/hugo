#+title: inf
#+date: 2024-12-31T00:23:13+01:00

* Python: Tabellarische Datenverarbeitung mit Pandas
:PROPERTIES:
:CUSTOM_ID: python-tabellarische-datenverarbeitung-mit-pandas
:END:
Dieses Notebook dient der Vermittlung der Grundlagen der Verarbeitung
von tabellarischen Daten in Python.

Die Inhalte basieren unter anderem auf

- Wiegand; Python 3 Lernen und professionell anwenden; 7. Auflage; MITP
  Verlag 2018
- Herold et.al.; Grundlagen der Informatik; 3. Auflage; Pearson 2017

Für die Generierung der Texte und Aufgaben wurde zum Teil auf GPT4 von
OpenAI genutzt.

Bitte nutzen Sie auch das Pandas Cheat Sheet, welches Sie im Moodle als
PDF finden.


* Python: Tabellarische Datenverarbeitung mit Pandas
:PROPERTIES:
:CUSTOM_ID: python-tabellarische-datenverarbeitung-mit-pandas
:END:


- *Pandas*: Eine leistungsstarke Open-Source-Bibliothek für Datenanalyse
  und -manipulation in Python.
- *DataFrame*: Zentrale Datenstruktur in Pandas, ähnlich einer Tabelle
  in einer relationalen Datenbank oder einem Excel-Arbeitsblatt.
- *Struktur eines DataFrame*: Besteht aus Zeilen und Spalten, wobei jede
  Spalte einen bestimmten Datentyp (int, float, str, etc.) haben kann.
- *Verwendung von DataFrames*: Nützlich für die Analyse und Manipulation
  großer Datenmengen. Bietet Funktionen zum Filtern, Sortieren,
  Gruppieren, Transformieren und Visualisieren von Daten.
- *Datenquellen für DataFrames*: Ermöglicht das Laden von Daten aus
  verschiedenen Quellen (z.B. CSV-, Excel-Dateien, SQL-Datenbanken) und
  das Speichern in verschiedenen Formaten.
- *Erstellung eines DataFrame*: Ein DataFrame kann durch Aufruf der
  Funktion pd.DataFrame() und Übergabe eines Dictionaries erstellt
  werden.


** Einleitung zu Pandas DataFrames
:PROPERTIES:
:CUSTOM_ID: einleitung-zu-pandas-dataframes
:END:
Pandas ist eine leistungsstarke und weit verbreitete
Open-Source-Bibliothek für Datenanalyse und -manipulation in Python. Sie
bietet Datenstrukturen und Funktionen, die für die Arbeit mit
strukturierten Daten unerlässlich sind. Der zentrale Bestandteil von
Pandas ist der DataFrame, eine zweidimensionale, tabellenartige
Datenstruktur, die flexibel und effizient in der Handhabung ist.

Ein DataFrame ist ähnlich wie eine Tabelle in einer relationalen
Datenbank oder ein Arbeitsblatt in Excel. Er besteht aus Zeilen und
Spalten, wobei jede Spalte einen bestimmten Datentyp (int, float, str,
etc.) haben kann. Jede Zeile in einem DataFrame repräsentiert einen
Eintrag, und jede Spalte repräsentiert eine bestimmte Art von
Information, ähnlich wie in einer Datenbanktabelle.

DataFrames sind besonders nützlich, wenn es darum geht, große Mengen von
Daten zu analysieren und zu manipulieren. Sie bieten eine Vielzahl von
Funktionen, um Daten zu filtern, zu sortieren, zu gruppieren, zu
transformieren und zu visualisieren. Darüber hinaus ermöglichen sie es,
Daten aus verschiedenen Quellen zu laden (z.B. CSV-, Excel-Dateien,
SQL-Datenbanken) und in verschiedenen Formaten zu speichern.

Ein einfacher DataFrame kann wie folgt erstellt werden:

#+begin_src
# Importieren der Pandas Bibliothek
import pandas as pd

# Erstellen eines DataFrames
df = pd.DataFrame(data=[["Anna", 28, "Berlin"],
                        ["Ben", 32, "Hamburg"],
                        ["Chris", 25, "München"]], 
                  columns=["Name","Alter", "Stadt"])

print(df)
#+end_src

Dieser Code erstellt einen DataFrame mit den Spalten "Name", "Alter" und
"Stadt" und drei Einträgen. Der DataFrame sieht dann so aus:

#+begin_example
   Name  Alter     Stadt
0  Anna     28    Berlin
1   Ben     32   Hamburg
2 Chris     25   München
#+end_example

In den folgenden Kapiteln werden wir uns genauer mit den verschiedenen
Aspekten von Pandas DataFrames beschäftigen, von der Erstellung und
Datenmanipulation bis hin zur Datenanalyse und Visualisierung. Wir
werden auch fortgeschrittene Funktionen von Pandas kennenlernen und
praktische Übungen durchführen, um das Gelernte zu vertiefen.


*** Installation von Pandas
:PROPERTIES:
:CUSTOM_ID: installation-von-pandas
:END:
Sollten Sie einen Fehler beim Laden der Pandas Bibliothek erhalten,
installieren Sie diese bitte mit dem folgenden Befehl:

#+begin_src
!pip install pandas
#+end_src

Alternativ können Sie Pandas auch über die Anaconda-Distribution
installieren. Eine Anleitung wie man Bibliotheken in Python über
Anaconda installiert finden Sie
[[https://docs.anaconda.com/anaconda/navigator/tutorials/manage-packages/][hier]].

#+begin_src
# Importieren der Pandas Bibliothek
import pandas as pd

# Erstellen eines DataFrames
df = pd.DataFrame(data=[["Anna", 28, "Berlin"],
                        ["Ben", 32, "Hamburg"],
                        ["Chris", 25, "München"]], 
                  columns=["Name","Alter", "Stadt"])

print(df)
#+end_src

#+begin_example
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
    Name  Alter    Stadt
0   Anna     28   Berlin
1    Ben     32  Hamburg
2  Chris     25  München
#+end_example


** Aufgabe 1: DataFrame erstellen
:PROPERTIES:
:CUSTOM_ID: aufgabe-1-dataframe-erstellen
:END:
Erstellen Sie einen DataFrame, der die folgenden Daten enthält:

| Tier  | Alter | Zoo     |
|-------+-------+---------|
| Panda | 4     | Berlin  |
| Löwe  | 3     | Köln    |
| Maus  | 2     | München |

#+begin_src
# Musterlösung 1

# Importieren der Pandas Bibliothek
import pandas as pd

# Erstellen eines DataFrames
df = pd.DataFrame(data=[],
                  columns=[])

# Ausgabe des erstellten DataFrames
print(df)
#+end_src

#+begin_example
    Tier  Alter      Zoo
0  panda      4   Berlin
1   Löwe      3     Köln
2   Maus      2  München
#+end_example


** Erstellen eines DataFrames
:PROPERTIES:
:CUSTOM_ID: erstellen-eines-dataframes
:END:
- *DataFrame*: Eine zweidimensionale Datenstruktur, ähnlich wie eine
  Tabelle in einer relationalen Datenbank oder eine Excel-Tabelle.
- *Pandas-Bibliothek*: Bietet den DataFrame als zentrales Element für
  Datenmanipulation und Datenanalyse.
- *Importieren der Pandas-Bibliothek*: Mit dem Befehl
  =import pandas as pd=.
- *Erstellen eines DataFrame*: Verschiedene Möglichkeiten, abhängig von
  der Datenquelle und dem Datenformat.
  - Aus einer Liste von Listen: Jede innere Liste wird zu einer Zeile im
    DataFrame.
  - Aus einem Dictionary: Die Schlüssel werden zu den Spaltennamen und
    die Werte zu den Daten in den Spalten.
  - Aus einer externen Datei: Mit den Funktionen =pd.read_csv()= oder
    =pd.read_excel()= kann ein DataFrame aus einer CSV-Datei oder einer
    Excel-Datei erstellt werden.
- *Grundlegender Schritt in der Datenanalyse*: Das Erstellen eines
  DataFrame ist ein grundlegender Schritt in der Datenanalyse mit
  Pandas.


*** Erstellen eines DataFrame in Pandas
:PROPERTIES:
:CUSTOM_ID: erstellen-eines-dataframe-in-pandas
:END:
Ein DataFrame ist eine zweidimensionale Datenstruktur, ähnlich wie eine
Tabelle in einer relationalen Datenbank oder eine Excel-Tabelle. Es
besteht aus Zeilen und Spalten, wobei jede Spalte einen bestimmten
Datentyp (int, float, str usw.) haben kann.

Ein DataFrame ist das zentrale Element der Pandas-Bibliothek und wird
häufig für Datenmanipulation und Datenanalyse verwendet. Es ermöglicht
eine effiziente Speicherung und Manipulation von strukturierten Daten
und bietet Funktionen zum schnellen Überblick, zum Filtern nach
Bedingungen und zur Berechnung von Statistiken.

Um einen DataFrame in Pandas zu erstellen, müssen wir zuerst die
Pandas-Bibliothek importieren. Dies geschieht mit dem Befehl
=import pandas as pd=. Die Abkürzung =pd= ist eine Konvention und
ermöglicht es uns, auf die Funktionen von Pandas zuzugreifen, indem wir
=pd= statt =pandas= schreiben.

#+begin_src
# Importieren der Pandas-Bibliothek
import pandas as pd
#+end_src

Es gibt verschiedene Möglichkeiten, einen DataFrame zu erstellen. Eine
der einfachsten ist die Verwendung einer Liste von Listen, wobei jede
innere Liste eine Zeile im DataFrame repräsentiert.

#+begin_src
# Erstellen eines DataFrame aus einer Liste von Listen
data = [['Alex', 10], ['Bob', 12], ['Clarke', 13]]
df = pd.DataFrame(data, columns=['Name', 'Age'])
print(df)
#+end_src

In diesem Beispiel erstellen wir einen DataFrame mit den Spalten 'Name'
und 'Age'. Jede innere Liste in der Liste =data= wird zu einer Zeile im
DataFrame.

Eine weitere Möglichkeit, einen DataFrame zu erstellen, ist die
Verwendung eines Dictionaries. Die Schlüssel des Dictionaries werden zu
den Spaltennamen und die Werte zu den Daten in den Spalten.

#+begin_src
# Erstellen eines DataFrame aus einem Dictionary
data = {'Name': ['Tom', 'Nick', 'John'], 'Age': [20, 21, 19]}
df = pd.DataFrame(data)
print(df)
#+end_src

In diesem Beispiel erstellen wir einen DataFrame mit den gleichen
Spalten 'Name' und 'Age', aber diesmal aus einem Dictionary.

Es ist auch möglich, einen DataFrame aus einer externen Datei zu
erstellen, wie einer CSV-Datei oder einer Excel-Datei. Dazu verwenden
wir die Funktionen =pd.read_csv()= oder =pd.read_excel()=.

#+begin_src
# Erstellen eines DataFrame aus einer CSV-Datei
df = pd.read_csv('file.csv')
print(df)
#+end_src

In diesem Beispiel lesen wir eine CSV-Datei und erstellen einen
DataFrame aus ihren Daten. Der Pfad zur Datei kann relativ zum aktuellen
Arbeitsverzeichnis oder absolut sein.

Zusammenfassend lässt sich sagen, dass das Erstellen eines DataFrame in
Pandas ein grundlegender Schritt in der Datenanalyse ist. Es gibt
verschiedene Möglichkeiten, einen DataFrame zu erstellen, je nachdem,
woher die Daten kommen und in welchem Format sie vorliegen.

#+begin_src
# Importieren der Pandas-Bibliothek
import pandas as pd
#+end_src

#+begin_src
# Erstellen eines DataFrame aus einer Liste von Listen
data = [['Alex', 10], ['Bob', 12], ['Clarke', 13]]
df = pd.DataFrame(data, columns=['Name', 'Age'])
print(df)
#+end_src

#+begin_example
     Name  Age
0    Alex   10
1     Bob   12
2  Clarke   13
#+end_example

#+begin_src
# Erstellen eines DataFrame aus einem Dictionary
data = {'Name': ['Tom', 'Nick', 'John'], 'Age': [20, 21, 19]}
df = pd.DataFrame(data)
print(df)
#+end_src

#+begin_example
   Name  Age
0   Tom   20
1  Nick   21
2  John   19
#+end_example

#+begin_src
# Erstellen eines DataFrame aus einer CSV-Datei
df = pd.read_csv('file.csv')
print(df)
#+end_src

#+begin_example
  StudentIn   Note  Bestanden
0       Max    1.3       True
1      Lena    1.3       True
2     Peter    4.0       True
3      Hans    5.0      False
#+end_example


*** Aufgabe 2: DataFrame aus Dictionary
:PROPERTIES:
:CUSTOM_ID: aufgabe-2-dataframe-aus-dictionary
:END:
Erstellen Sie einen DataFrame aus dem folgenden Dictionary. Die
Schlüssel sollen die Spaltennamen und die Werte die Daten in den Spalten
sein.

#+begin_src
autos = {'Marke': ['VW', 'BMW', 'Mercedes', 'Audi'], 'Modell': ['Golf', '3er', 'C-Klasse', 'A4'], 'Preis': [20000, 30000, 40000, 35000]}
#+end_src

#+begin_src
# Musterlösung

# Importieren der Pandas-Bibliothek
import pandas as pd

# Dictionary
autos = {}

# Erstellen eines DataFrame aus dem Dictionary
df = pd.DataFrame(autos)

# Ausgabe des DataFrame
print(df)
#+end_src

#+begin_example
      Marke    Modell  Preis
0        VW      Golf  20000
1       BMW       3er  30000
2  Mercedes  C-Klasse  40000
3      Audi        A4  35000
#+end_example


** Datenzugriff und -selektion
:PROPERTIES:
:CUSTOM_ID: datenzugriff-und--selektion
:END:


- *Datenzugriff in DataFrames*: Direkter Zugriff auf Spalten durch ihren
  Namen mit der Syntax =df['Spaltenname']=.
- *=loc= Methode*: Zugriff auf Daten durch ihren Label-basierten Index.
  Erlaubt auch die Auswahl von Daten basierend auf booleschen
  Bedingungen.
- *=iloc= Methode*: Zugriff auf Daten durch ihren integer-basierten
  Index, unabhängig von den Labels.
- *Zeilen- und spaltenbasierte Selektion*: Mit =loc= und =iloc= können
  sowohl Zeilen als auch Spalten ausgewählt werden. Bei =loc= wird die
  Syntax =df.loc[Zeilenlabel, 'Spaltenlabel']= verwendet, bei =iloc= die
  Syntax =df.iloc[Zeilenindex, Spaltenindex]=.


*** Zugriff auf Daten in einem DataFrame
:PROPERTIES:
:CUSTOM_ID: zugriff-auf-daten-in-einem-dataframe
:END:
Es gibt verschiedene Methoden, um auf Daten in einem DataFrame
zuzugreifen. Eine der einfachsten Methoden ist die direkte Auswahl einer
Spalte durch ihren Namen. Angenommen, wir haben einen DataFrame =df=,
der eine Spalte namens "A" enthält. Dann können wir auf diese Spalte
zugreifen, indem wir =df['A']= schreiben.

#+begin_src
import pandas as pd

# DataFrame erstellen
data = {'A': [1, 2, 3], 'B': [4, 5, 6], 'C': [7, 8, 9]}
df = pd.DataFrame(data)

# Zugriff auf Spalte 'A'
print(df['A'])
#+end_src


*** Selektion von Daten mit =loc= und =iloc=
:PROPERTIES:
:CUSTOM_ID: selektion-von-daten-mit-loc-und-iloc
:END:
Pandas bietet zwei leistungsfähige Methoden zur Datenabfrage und
-selektion: =loc= und =iloc=.

- =loc=: Diese Methode wird verwendet, um auf einen Datensatz durch
  seinen Label-basierten Index zuzugreifen. Sie ermöglicht auch die
  Auswahl von Daten basierend auf booleschen Bedingungen.

#+begin_src
# Zugriff auf die erste Zeile mit loc
print(df.loc[0])
#+end_src

- =iloc=: Diese Methode ermöglicht den Zugriff auf einen Datensatz durch
  seinen integer-basierten Index, unabhängig von den Labels.

#+begin_src
# Zugriff auf die erste Zeile mit iloc
print(df.iloc[0])
#+end_src

#+begin_src
df = pd.DataFrame(data = {'A': [1, 2, 3], 'B': [4, 5, 6], 'C': [7, 8, 9]},
                  index = ["eins", "zwei", "drei"])

print(df)

print("-"*10)

print(df.loc["eins"])

print("-"*10)

print(df.iloc[0])
#+end_src

#+begin_example
      A  B  C
eins  1  4  7
zwei  2  5  8
drei  3  6  9
----------
A    1
B    4
C    7
Name: eins, dtype: int64
----------
A    1
B    4
C    7
Name: eins, dtype: int64
#+end_example


*** Zeilen- und spaltenbasierte Selektion
:PROPERTIES:
:CUSTOM_ID: zeilen--und-spaltenbasierte-selektion
:END:
Mit =loc= und =iloc= können wir auch zeilen- und spaltenbasierte
Selektionen durchführen. Angenommen, wir möchten die erste Zeile und die
erste Spalte unseres DataFrames auswählen. Mit =loc= würden wir
schreiben =df.loc[0, 'A']= und mit =iloc= =df.iloc[0, 0]=.

#+begin_src
# Zeilen- und spaltenbasierte Selektion mit loc
print(df.loc[0, 'A'])

# Zeilen- und spaltenbasierte Selektion mit iloc
print(df.iloc[0, 0])
#+end_src

#+begin_src
df = pd.DataFrame(data = {'A': [1, 2, 3], 'B': [4, 5, 6], 'C': [7, 8, 9]},
                  index = ["eins", "zwei", "drei"])

print(df)

print("-"*10)

print(df.loc["eins", "A"])

print("-"*10)

print(df.iloc[0, 0])
#+end_src

#+begin_example
      A  B  C
eins  1  4  7
zwei  2  5  8
drei  3  6  9
----------
1
----------
1
#+end_example


*** Aufgabe 3: Datenzugriff
:PROPERTIES:
:CUSTOM_ID: aufgabe-3-datenzugriff
:END:
Erstellen Sie einen DataFrame mit den Namen und Alter von fünf Personen.
Der DataFrame sollte zwei Spalten ("Name" und "Alter") und fünf Zeilen
haben. Greifen Sie dann auf die Spalte "Alter" zu und zeigen Sie das
Alter der dritten Person an.

#+begin_src
# Musterlösung

import pandas as pd

# DataFrame erstellen
data = 
df = pd.DataFrame(data)

# Zugriff auf Spalte 'Alter'
print(df['Alter'])

# Alter der dritten Person anzeigen
print(df.loc[])
#+end_src

#+begin_example
0    23
1    25
2    22
3    24
4    26
Name: Alter, dtype: int64
22
#+end_example


​## Manipulation von DataFrame-Daten


- *Hinzufügen von Spalten*: Neue Spalten können durch Zuweisung eines
  neuen Spaltennamens und eines Wertes oder einer Liste von Werten
  hinzugefügt werden.
- *Entfernen von Spalten*: Die Methode =drop()= wird verwendet, um
  Spalten zu entfernen. Sie benötigt den Namen der Spalte und die
  Achseninformation (axis=1 für Spalten).
- *Modifizieren von Spalten*: Spalten können direkt überschrieben oder
  durch eine Funktion verändert werden.
- *Hinzufügen von Zeilen*: Die Methode =append()= wird verwendet, um
  Zeilen hinzuzufügen.
- *Entfernen von Zeilen*: Die Methode =drop()= wird verwendet, um Zeilen
  zu entfernen. Sie benötigt den Index der Zeile und die
  Achseninformation (axis=0 für Zeilen).
- *Umstrukturieren von Daten*: Funktionen wie =pivot()=, =melt()=,
  =stack()= und =unstack()= ermöglichen das Umstrukturieren von Daten in
  verschiedene Formate.
- *Wichtigkeit der Datenmanipulation*: Die Kenntnis dieser Methoden ist
  essentiell, um Daten effektiv für die Analyse vorzubereiten.


*** Manipulation von DataFrame-Daten
:PROPERTIES:
:CUSTOM_ID: manipulation-von-dataframe-daten
:END:
Pandas DataFrames sind äußerst flexibel und erlauben eine Vielzahl von
Manipulationen. Diese Manipulationen sind essentiell, um Daten in die
gewünschte Form zu bringen, bevor sie analysiert werden. In diesem
Abschnitt werden wir uns auf das Hinzufügen, Entfernen und Modifizieren
von Spalten und Zeilen in einem DataFrame konzentrieren. Darüber hinaus
werden wir auch das Umstrukturieren von Datenstrukturen behandeln.

*Hinzufügen von Spalten*

Das Hinzufügen von Spalten zu einem DataFrame ist einfach und intuitiv.
Sie können eine neue Spalte hinzufügen, indem Sie einen neuen
Spaltennamen als Index verwenden und ihm einen Wert oder eine Liste von
Werten zuweisen.

#+begin_src
import pandas as pd

# DataFrame erstellen
df = pd.DataFrame({
   'A': [1, 2, 3],
   'B': [4, 5, 6]
})

# Neue Spalte hinzufügen
df['C'] = [7, 8, 9]

print(df)
#+end_src


*** Entfernen von Spalten
:PROPERTIES:
:CUSTOM_ID: entfernen-von-spalten
:END:
Das Entfernen von Spalten ist ebenso einfach. Die Methode =drop()= kann
verwendet werden, um Spalten zu entfernen. Sie benötigen den Namen der
Spalte und die Achseninformation (axis=1 für Spalten).

#+begin_src
# Spalte entfernen
df = df.drop('C', axis=1)

print(df)
#+end_src

#+begin_src
# DataFrame erstellen
df = pd.DataFrame({
   'A': [1, 2, 3],
   'B': [4, 5, 6],
   'C': [7, 8, 9]
})

# Spalte C entfernen
df = df.drop("C", axis = 1)

df
#+end_src

#+RESULTS:
:    A  B
: 0  1  4
: 1  2  5
: 2  3  6
#+begin_src
# Alternativ inplace Bearbeitung des DataFrames
df.drop("B", axis = 1, inplace = True)
df
#+end_src

#+RESULTS:
:    A
: 0  1
: 1  2
: 2  3


*** Modifizieren von Spalten
:PROPERTIES:
:CUSTOM_ID: modifizieren-von-spalten
:END:
Spalten können auch modifiziert werden, indem sie direkt überschrieben
oder durch eine Funktion verändert werden.

#+begin_src
# Spalte modifizieren
df['A'] = df['A'] * 2

print(df)
#+end_src

#+begin_src
# DataFrame erstellen
df = pd.DataFrame({
   'A': [1, 2, 3],
   'B': [4, 5, 6],
   'C': [7, 8, 9]
})

# Spalte modifizieren
df['A'] = df['A'] * 2

df
#+end_src

#+RESULTS:
:    A  B  C
: 0  2  4  7
: 1  4  5  8
: 2  6  6  9


*** Hinzufügen und Entfernen von Zeilen
:PROPERTIES:
:CUSTOM_ID: hinzufügen-und-entfernen-von-zeilen
:END:
Zeilen können mit der Methode =append()= hinzugefügt werden. Um Zeilen
zu entfernen, verwenden Sie die Methode =drop()= mit dem Index der Zeile
und der Achseninformation (axis=0 für Zeilen).

#+begin_src
# Zeile hinzufügen
new_row = pd.Series([10, 11], index=['A', 'B'])
df = df.append(new_row, ignore_index=True)

# Zeile entfernen
df = df.drop(2, axis=0)

print(df)
#+end_src

#+begin_src
# DataFrame erstellen
df = pd.DataFrame({
   'A': [1, 2, 3],
   'B': [4, 5, 6],
   'C': [7, 8, 9]
})

# Zeile entfernen
df = df.drop(2, axis=0)

df
#+end_src

#+RESULTS:
:    A  B  C
: 0  1  4  7
: 1  2  5  8


*** Umstrukturieren von Daten
:PROPERTIES:
:CUSTOM_ID: umstrukturieren-von-daten
:END:
Pandas bietet auch Funktionen zum Umstrukturieren von Daten, wie
=pivot()= für die Erstellung einer Pivot-Tabelle, =melt()= zum Umwandeln
von Spalten in Zeilen und =stack()=/=unstack()= zum Stapeln oder
Entstapeln von Daten.

#+begin_src
# Pivot-Tabelle erstellen
pivot_df = df.pivot(index='A', columns='B', values='C')

print(pivot_df)
#+end_src

#+begin_src
# Beispiel DataFrame erstellen
df = pd.DataFrame({
    'Date': ['2021-01-01', '2021-01-01', '2021-01-02', '2021-01-02'],
    'Product': ['A', 'B', 'A', 'B'],
    'Sales': [10, 15, 20, 25]
})

print(df)

print("-"*10)

# Pivot-Tabelle erstellen
pivot_df = df.pivot(index='Date', columns='Product', values='Sales')

print(pivot_df)
#+end_src

#+begin_example
         Date Product  Sales
0  2021-01-01       A     10
1  2021-01-01       B     15
2  2021-01-02       A     20
3  2021-01-02       B     25
----------
Product      A   B
Date              
2021-01-01  10  15
2021-01-02  20  25
#+end_example


*** Aufgabe 4: Datenmanipulation
:PROPERTIES:
:CUSTOM_ID: aufgabe-4-datenmanipulation
:END:
Erstellen Sie einen DataFrame mit den Namen und Alter von fünf Personen.
Fügen Sie eine Spalte hinzu, die das Alter in Monaten anzeigt. Entfernen
Sie anschließend die Spalte mit dem Alter in Jahren.

#+begin_src
import pandas as pd

# DataFrame erstellen
df = pd.DataFrame({
   'Name': ['Anna', 'Ben', 'Chris', 'Diana', 'Eli'],
   'Alter': [25, 30, 35, 40, 45]
})

# Spalte hinzufügen
df['Alter_in_Monaten'] = 

# Spalte entfernen
df = 

print(df)
#+end_src

#+begin_example
    Name  Alter  Alter_in_Monaten Käsekuchen
0   Anna     25               300       Käse
1    Ben     30               360       Käse
2  Chris     35               420       Käse
3  Diana     40               480       Käse
4    Eli     45               540       Käse
#+end_example


​## Filtern und Sortieren von Daten


- *Filtern von Daten*: Auswahl spezifischer Daten aus einem DataFrame,
  die bestimmten Kriterien entsprechen.
  - Bedingte Abfragen in Pandas ermöglichen das Filtern von Daten.
  - Beispiel: Auswahl aller Personen in einem DataFrame, die älter als
    20 Jahre sind.
- *Sortieren von Daten*: Anzeige der Daten in einer bestimmten
  Reihenfolge.
  - Die Methode =sort_values()= in Pandas ermöglicht das Sortieren eines
    DataFrame nach einer oder mehreren Spalten.
  - Daten können in aufsteigender oder absteigender Reihenfolge sortiert
    werden.
- *Wichtigkeit des Filterns und Sortierens*: Beide Operationen sind
  wesentliche Bestandteile der Datenanalyse.
  - Filtern ermöglicht die Extraktion spezifischer Daten.
  - Sortieren ermöglicht die Anzeige der Daten in einer sinnvollen
    Reihenfolge.
  - Pandas bietet effiziente und einfache Methoden für beide Aufgaben


*** Filtern von Daten
:PROPERTIES:
:CUSTOM_ID: filtern-von-daten
:END:
Das Filtern von Daten ermöglicht es uns, spezifische Daten aus einem
DataFrame auszuwählen, die bestimmten Kriterien entsprechen. In Pandas
können wir dies durch bedingte Abfragen erreichen.

Angenommen, wir haben einen DataFrame =df= mit den Spalten 'Name',
'Alter' und 'Stadt'. Wenn wir nur die Daten der Personen anzeigen
möchten, die älter als 20 Jahre sind, können wir die folgende bedingte
Abfrage verwenden:

#+begin_src
df_filtered = df[df['Alter'] > 20]
print(df_filtered)
#+end_src

In diesem Code erstellen wir einen neuen DataFrame =df_filtered=, der
nur die Zeilen aus =df= enthält, bei denen das Alter größer als 20 ist.

#+begin_src
data = {"Name":["Alice","Bob"],
       "Alter":[23,32],
       "Stadt":["Berlin","Köln"]}

df = pd.DataFrame(data)

print(df)

print("-"*10)

df_filtered = df[df["Alter"] > 25]

print(df_filtered)
#+end_src

#+begin_example
    Name  Alter   Stadt
0  Alice     23  Berlin
1    Bob     32    Köln
----------
  Name  Alter Stadt
1  Bob     32  Köln
#+end_example


*** Sortieren von Daten
:PROPERTIES:
:CUSTOM_ID: sortieren-von-daten
:END:
Das Sortieren von Daten ist eine weitere wichtige Funktion, die es uns
ermöglicht, die Daten in einer bestimmten Reihenfolge anzuzeigen. In
Pandas können wir die Methode =sort_values()= verwenden, um einen
DataFrame nach einer oder mehreren Spalten zu sortieren.

Angenommen, wir möchten unseren DataFrame =df= nach dem Alter in
aufsteigender Reihenfolge sortieren. Wir können dies mit dem folgenden
Code erreichen:

#+begin_src
df_sorted = df.sort_values('Alter')
print(df_sorted)
#+end_src

In diesem Code erstellen wir einen neuen DataFrame =df_sorted=, der alle
Zeilen aus =df= enthält, sortiert nach dem Alter in aufsteigender
Reihenfolge.

Es ist auch möglich, die Daten in absteigender Reihenfolge zu sortieren,
indem wir den Parameter =ascending=False= setzen:

#+begin_src
df_sorted_desc = df.sort_values('Alter', ascending=False)
print(df_sorted_desc)
#+end_src

In diesem Code erstellen wir einen neuen DataFrame =df_sorted_desc=, der
alle Zeilen aus =df= enthält, sortiert nach dem Alter in absteigender
Reihenfolge.

#+begin_src
data = {"Name":["Alice","Bob"],
       "Alter":[23,32],
       "Stadt":["Berlin","Köln"]}

df = pd.DataFrame(data)

print(df)

print("-"*10)

df_sorted = df.sort_values('Alter', ascending=False)

print(df_sorted)
#+end_src

#+begin_example
    Name  Alter   Stadt
0  Alice     23  Berlin
1    Bob     32    Köln
----------
    Name  Alter   Stadt
1    Bob     32    Köln
0  Alice     23  Berlin
#+end_example


*** Aufgabe 5: Filtern und Sortieren
:PROPERTIES:
:CUSTOM_ID: aufgabe-5-filtern-und-sortieren
:END:
Erstellen Sie einen DataFrame mit den folgenden Daten und filtern Sie
alle Zeilen heraus, in denen der Preis über 20 liegt. Sortieren Sie dann
absteigend und geben sie das DataFrame aus.

| Produkt | Preis |
|---------+-------|
| Apfel   | 10    |
| Banane  | 15    |
| Kirsche | 25    |
| Dattel  | 30    |
| Birne   | 22    |

#+begin_src
# Importieren der Pandas Bibliothek
import pandas as pd

# Erstellen des DataFrames
df = pd.DataFrame({
    'Produkt': [],
    'Preis': []
})

# Filtern der Zeilen, in denen der Preis über 20 liegt
df_filtered = 

# Sortieren, absteigend nach Preis
df_sorted = 

# Ausgabe des DateFrames
print(df_sorted)
#+end_src

#+begin_example
   Produkt  Preis
3   Dattel     30
2  Kirsche     25
4    Birne     22
#+end_example


** Grundlegende statistische Analysen
:PROPERTIES:
:CUSTOM_ID: grundlegende-statistische-analysen
:END:


- *Statistische Analysen*: Zentraler Bestandteil der Datenwissenschaft,
  ermöglicht das Erkennen von Mustern, das Testen von Hypothesen und das
  Treffen von Vorhersagen.
- *Statistische Funktionen in Pandas*: Ermöglichen grundlegende
  statistische Analysen auf einem DataFrame. Beinhalten Funktionen zur
  Berechnung des Durchschnitts (=mean()=), des Medians (=median()=), der
  Summe (=sum()=), des Maximums (=max()=) und des Minimums (=min()=).
  Diese Funktionen können auf das gesamte DataFrame oder auf einzelne
  Spalten angewendet werden.
- *Gruppieren und Aggregieren von Daten*: Mit der =groupby()= Funktion
  in Pandas können Daten basierend auf bestimmten Kriterien gruppiert
  und Aggregationsfunktionen auf diese Gruppen angewendet werden. Dies
  ist ein wichtiger Aspekt der statistischen Analyse.


*** Statistische Funktionen in Pandas
:PROPERTIES:
:CUSTOM_ID: statistische-funktionen-in-pandas
:END:
Pandas stellt eine Reihe von Methoden zur Verfügung, um grundlegende
statistische Analysen auf einem DataFrame durchzuführen. Dazu gehören
Funktionen zur Berechnung des Durchschnitts (=mean()=), des Medians
(=median()=), der Summe (=sum()=), des Maximums (=max()=) und des
Minimums (=min()=). Diese Funktionen können auf das gesamte DataFrame
oder auf einzelne Spalten angewendet werden.

Angenommen, wir haben den folgenden DataFrame:

#+begin_src
import pandas as pd

# DataFrame erstellen
df = pd.DataFrame({
    "Alter": [23, 24, 22, 25, 27, 23, 25, 24],
    "Gehalt": [3500, 4000, 3000, 4500, 4000, 3500, 4000, 4500]
})

print(df)
#+end_src

Wir können die durchschnittlichen Werte für jede Spalte berechnen, indem
wir die =mean()= Funktion verwenden:

#+begin_src
# Durchschnitt berechnen
durchschnitt = df.mean()
print(durchschnitt)
#+end_src

#+begin_src
import pandas as pd

# DataFrame erstellen
df = pd.DataFrame({
    "Alter": [23, 24, 22, 25, 27, 23, 25, 24],
    "Gehalt": [3500, 4000, 3000, 4500, 4000, 3500, 4000, 4500]
})
#+end_src

#+begin_src
# Durchschnitt berechnen
durchschnitt = df.mean()
print(durchschnitt)
#+end_src

#+begin_example
Alter       24.125
Gehalt    3875.000
dtype: float64
#+end_example

#+begin_src
# Maximum berechnen
maximum = df.max()
print(maximum)
#+end_src

#+begin_example
Alter       27
Gehalt    4500
dtype: int64
#+end_example

#+begin_src
# Minimum berechen
minimum = df.min()
print(minimum)
#+end_src

#+begin_example
Alter       22
Gehalt    3000
dtype: int64
#+end_example

#+begin_src
# Summe berechnen
summe = df.sum()
print(summe)
#+end_src

#+begin_example
Alter       193
Gehalt    31000
dtype: int64
#+end_example


*** Gruppieren und Aggregieren von Daten
:PROPERTIES:
:CUSTOM_ID: gruppieren-und-aggregieren-von-daten
:END:


Ein weiterer wichtiger Aspekt der statistischen Analyse ist das
Gruppieren und Aggregieren von Daten. Mit der =groupby()= Funktion in
Pandas können wir Daten basierend auf bestimmten Kriterien gruppieren
und dann Aggregationsfunktionen auf diese Gruppen anwenden.

Angenommen, wir haben einen zusätzlichen DataFrame, der die Abteilung
für jeden Mitarbeiter enthält:

#+begin_src
# DataFrame erstellen
df = pd.DataFrame({
    "Abteilung": ["Marketing", "Vertrieb", "Marketing", "Vertrieb", "Marketing", "Vertrieb", "Marketing", "Vertrieb"],
    "Alter": [23, 24, 22, 25, 27, 23, 25, 24],
    "Gehalt": [3500, 4000, 3000, 4500, 4000, 3500, 4000, 4500]
})

print(df)
#+end_src

Wir können die Daten nach Abteilung gruppieren und das durchschnittliche
Gehalt in jeder Abteilung berechnen:

#+begin_src
# Daten gruppieren und Durchschnitt berechnen
gruppierte_daten = df.groupby("Abteilung").mean()
print(gruppierte_daten)
#+end_src


*** Aufgabe 6: Statistik berechnen
:PROPERTIES:
:CUSTOM_ID: aufgabe-6-statistik-berechnen
:END:
Erstellen Sie einen DataFrame mit den folgenden Daten:

#+begin_src
Namen = ['Anna', 'Ben', 'Carla', 'Daniel', 'Eva', 'Frank']
Alter = [23, 24, 22, 25, 27, 23]
Gehalt = [3500, 4000, 3000, 4500, 4000, 3500]
Abteilung = ['Marketing', 'Vertrieb', 'Marketing', 'Vertrieb', 'Marketing', 'Vertrieb']
#+end_src

Berechnen Sie das Durchschnittsalter und das durchschnittliche Gehalt
aller Mitarbeiter. Berechnen Sie die Werte auch je Abteilung.

#+begin_src
import pandas as pd

# Daten erstellen
data = 

# DataFrame erstellen
df = pd.DataFrame(data)

# Durchschnittsalter und durchschnittliches Gehalt berechnen
durchschnitt_alter = 
durchschnitt_gehalt = 

print("Durchschnittsalter: ", durchschnitt_alter)
print("Durchschnittsgehalt: ", durchschnitt_gehalt)
#+end_src

#+begin_example
Durchschnittsalter:  27.5
Durchschnittsgehalt:  3750.0
#+end_example

#+begin_src
# Dataframe nach Abteilung aggregieren

df_abt = 

# Durchschnittsalter und durchschnittliches Gehalt berechnen
durchschnitt_alter_abt = df_abt['Alter'].mean()
durchschnitt_gehalt_abt = df_abt['Gehalt'].mean()

print("Durchschnittsalter: ", durchschnitt_alter_abt)
print("Durchschnittsgehalt: ", durchschnitt_gehalt_abt)
#+end_src

#+begin_example
Durchschnittsalter:  Abteilung
Marketing    31.0
Vertrieb     24.0
Name: Alter, dtype: float64
Durchschnittsgehalt:  Abteilung
Marketing    3500.0
Vertrieb     4000.0
Name: Gehalt, dtype: float64
#+end_example


** *Fortgeschrittene Funktionen in Pandas
:PROPERTIES:
:CUSTOM_ID: fortgeschrittene-funktionen-in-pandas
:END:


- *Fehlende Daten behandeln*: Pandas bietet Funktionen wie =isnull()=,
  =notnull()=, =dropna()=, und =fillna()= zur Identifizierung und
  Behandlung von fehlenden Daten.
- *Zeitreihenanalyse*: Pandas unterstützt umfangreiche Funktionen für
  die Arbeit mit Zeitreihendaten, einschließlich der Erstellung von
  Zeitstempeln, der Umwandlung von Daten in verschiedene Frequenzen und
  der Arbeit mit Zeitzonen.
- *Bedingte Operationen*: Mit Pandas können bedingte Operationen auf
  DataFrames durchgeführt werden, ähnlich wie in Excel. Es ermöglicht
  die Erstellung neuer Spalten basierend auf den Werten anderer Spalten.
- *Vielfältige Funktionen*: Die genannten Funktionen sind nur ein
  kleiner Teil dessen, was Pandas zu bieten hat. Es gibt noch viele
  weitere fortgeschrittene Funktionen, die zur Datenanalyse und
  -manipulation genutzt werden können.


*** Fehlende Daten behandeln
:PROPERTIES:
:CUSTOM_ID: fehlende-daten-behandeln
:END:
In der realen Welt sind Daten oft unvollständig oder fehlerhaft. Pandas
bietet mehrere Funktionen, um mit fehlenden Daten umzugehen. Die
Funktionen =isnull()= und =notnull()= können verwendet werden, um zu
überprüfen, ob in einem DataFrame fehlende Werte vorhanden sind.

#+begin_src
import pandas as pd
import numpy as np

# Erstellen eines DataFrame mit fehlenden Werten
df = pd.DataFrame({'A': [1, 2, np.nan],
                   'B': [5, np.nan, np.nan],
                   'C': [1, 2, 3]})

print(df.isnull())  # Gibt einen DataFrame mit Booleans zurück, die anzeigen, wo die Werte fehlen
#+end_src

Die Funktion =dropna()= kann verwendet werden, um Zeilen oder Spalten
mit fehlenden Werten zu entfernen, während die Funktion =fillna()=
verwendet werden kann, um fehlende Werte durch einen bestimmten Wert zu
ersetzen.

#+begin_src
print(df.dropna())  # Entfernt alle Zeilen mit fehlenden Werten
print(df.fillna(value='FILL VALUE'))  # Ersetzt alle fehlenden Werte durch 'FILL VALUE'
#+end_src


*** Zeitreihenanalyse
:PROPERTIES:
:CUSTOM_ID: zeitreihenanalyse
:END:
Pandas wurde ursprünglich für die Finanzindustrie entwickelt, daher
bietet es umfangreiche Funktionen für die Arbeit mit Zeitreihendaten.
Mit Pandas können Sie Daten resampeln, um sie in eine andere Frequenz
umzuwandeln (z.B. von täglich zu monatlich), Zeitstempel erstellen und
mit Zeitzonen arbeiten.

#+begin_src
# Erstellen eines Datumsbereichs
dates = pd.date_range('20200101', periods=6)

# Erstellen eines DataFrame mit den Daten als Index
df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list('ABCD'))

print(df)
#+end_src


*** Bedingte Operationen
:PROPERTIES:
:CUSTOM_ID: bedingte-operationen
:END:
Pandas ermöglicht es Ihnen, bedingte Operationen auf DataFrames
durchzuführen, ähnlich wie Sie es in Excel tun würden. Sie können
beispielsweise eine neue Spalte erstellen, die auf den Werten anderer
Spalten basiert.

#+begin_src
# Erstellen eines DataFrame
df = pd.DataFrame({'A': [1, 2, 3, 4],
                   'B': [10, 20, 30, 40],
                   'C': ['Apple', 'Banana', 'Cherry', 'Date']})

# Erstellen einer neuen Spalte basierend auf einer Bedingung
df['D'] = np.where(df['A'] > 2, 'large', 'small')

print(df)
#+end_src


** Praktische Übungen mit Pandas DataFrames
:PROPERTIES:
:CUSTOM_ID: praktische-übungen-mit-pandas-dataframes
:END:


Nachdem wir uns nun intensiv mit den verschiedenen Aspekten von Pandas
DataFrames auseinandergesetzt haben, ist es an der Zeit, das Gelernte
praktisch anzuwenden. Praktische Übungen sind ein wesentlicher
Bestandteil des Lernprozesses, da sie es uns ermöglichen, das
theoretische Wissen in die Praxis umzusetzen und zu vertiefen. In diesem
Abschnitt werden wir uns daher mit einigen Übungsaufgaben beschäftigen,
die auf den bisher behandelten Themen basieren.

*Aufgabe 1: Erstellen eines DataFrames*

Erstellen Sie einen DataFrame aus dem folgenden Dictionary:

#+begin_src
data = {
    "Name": ["Anna", "Ben", "Chris", "Diana", "Eva", "Frank", "Grace", "Harold"],
    "Alter": [23, 31, 35, 19, 45, 52, 33, 40],
    "Stadt": ["Berlin", "Hamburg", "München", "Köln", "Stuttgart", "Hamburg", "Berlin", "München"],
    "Beruf": ["Ingenieur", "Arzt", "Künstler", "Student", "Architekt", "Ingenieur", "Arzt", "Künstler"]
}
#+end_src

*Aufgabe 2: Datenzugriff und -selektion*

Greifen Sie auf die Spalte "Name" zu und geben Sie die ersten 5 Einträge
aus.

*Aufgabe 3: Manipulation von DataFrame-Daten*

Fügen Sie eine neue Spalte "Einkommen" hinzu und füllen Sie sie mit
"zufälligen" Werten zwischen 2000 und 5000.

*Aufgabe 4: Filtern und Sortieren von Daten*

Filtern Sie den DataFrame, um nur die Einträge anzuzeigen, die aus
Berlin kommen und sortieren Sie das Ergebnis nach dem Alter in
absteigender Reihenfolge.

*Aufgabe 5: Grundlegende statistische Analysen*

Berechnen Sie das durchschnittliche Alter der Personen in Ihrem
DataFrame.

*Aufgabe 6: Gruppieren und Aggregieren von Daten*

Gruppieren Sie die Daten nach Beruf und berechnen Sie das
durchschnittliche Einkommen für jede Berufsgruppe.

#+begin_src
import pandas as pd

# Dictionary mit Daten
data = {
    "Name": ["Anna", "Ben", "Chris", "Diana", "Eva", "Frank", "Grace", "Harold"],
    "Alter": [23, 31, 35, 19, 45, 52, 33, 40],
    "Stadt": ["Berlin", "Hamburg", "München", "Köln", "Stuttgart", "Hamburg", "Berlin", "München"],
    "Beruf": ["Ingenieur", "Arzt", "Künstler", "Student", "Architekt", "Ingenieur", "Arzt", "Künstler"]
}

# DataFrame erstellen
df = 
print("DataFrame:")
display(df)
#+end_src

#+begin_example
DataFrame:
#+end_example

#+begin_example
     Name  Alter      Stadt      Beruf
0    Anna     23     Berlin  Ingenieur
1     Ben     31    Hamburg       Arzt
2   Chris     35    München   Künstler
3   Diana     19       Köln    Student
4     Eva     45  Stuttgart  Architekt
5   Frank     52    Hamburg  Ingenieur
6   Grace     33     Berlin       Arzt
7  Harold     40    München   Künstler
#+end_example

#+begin_src
# Zugriff auf die Spalte "Name"
names = 
print(f"Erste 5 Namen: {names}")
#+end_src

#+begin_example
Erste 5 Namen:
#+end_example

#+begin_example
0     Anna
1      Ben
2    Chris
3    Diana
4      Eva
Name: Name, dtype: object
#+end_example

#+begin_src
import numpy as np

# Hinzufügen einer neuen Spalte "Einkommen" mit zufälligen Werten zwischen 2000 und 5000
np.random.seed(0)  # Seed für Reproduzierbarkeit
# Verwenden Sie np.random.randint, um zufällige Ganzzahlen zu generieren
df["Einkommen"] = 
print("DataFrame mit Einkommen:") 
display(df)
#+end_src

#+begin_example
DataFrame mit Einkommen:
#+end_example

#+begin_example
     Name  Alter      Stadt      Beruf  Einkommen
0    Anna     23     Berlin  Ingenieur       4732
1     Ben     31    Hamburg       Arzt       4607
2   Chris     35    München   Künstler       3653
3   Diana     19       Köln    Student       2835
4     Eva     45  Stuttgart  Architekt       2763
5   Frank     52    Hamburg  Ingenieur       3731
6   Grace     33     Berlin       Arzt       3033
7  Harold     40    München   Künstler       2277
#+end_example

#+begin_src
# Filtern der Daten nach Stadt "Berlin" und Sortieren nach Alter in absteigender Reihenfolge
berlin_df = 
print("Einträge aus Berlin, sortiert nach Alter:")
display(berlin_df)
#+end_src

#+begin_example
Einträge aus Berlin, sortiert nach Alter:
#+end_example

#+begin_example
    Name  Alter   Stadt      Beruf  Einkommen
6  Grace     33  Berlin       Arzt       3033
0   Anna     23  Berlin  Ingenieur       4732
#+end_example

#+begin_src
# Durchschnittliches Alter berechnen
durchschnittliches_alter = 
print("Durchschnittliches Alter:", durchschnittliches_alter)
#+end_src

#+begin_example
Durchschnittliches Alter: 34.75
#+end_example

#+begin_src
# Gruppieren nach Beruf und Berechnen des durchschnittlichen Einkommens
durchschnittliches_einkommen = 
print("Durchschnittliches Einkommen nach Beruf:\n")
display(durchschnittliches_einkommen)
#+end_src

#+begin_example
Durchschnittliches Einkommen nach Beruf:

#+end_example

#+begin_example
Beruf
Architekt    2763.0
Arzt         3820.0
Ingenieur    4231.5
Künstler     2965.0
Student      2835.0
Name: Einkommen, dtype: float64
#+end_example
* Datenvisualisierung mit Python // Matplotlib
:PROPERTIES:
:CUSTOM_ID: datenvisualisierung-mit-python--matplotlib
:END:

- *Matplotlib*: Eine der bekanntesten und am häufigsten verwendeten
  Bibliotheken für die Datenvisualisierung in Python.
- *Datenvisualisierung*: Ein wichtiger Aspekt der Datenanalyse, der es
  ermöglicht, Muster, Trends und Beziehungen in den Daten zu erkennen.
- *Flexibilität*: Matplotlib bietet eine hohe Kontrolle über alle
  Aspekte eines Plots oder Diagramms und kann sowohl für einfache als
  auch für komplexe Visualisierungen verwendet werden.
- *Importieren von Matplotlib*: In der Regel wird Matplotlib unter dem
  Alias =plt= importiert.
- *Erstellen eines einfachen Plots*: Mit der Funktion =plot()= kann ein
  einfacher Plot erstellt werden, der eine Liste von Werten erwartet.
  Mit der Funktion =show()= wird der Plot angezeigt.
- *Weitere Möglichkeiten*: In den folgenden Abschnitten werden weitere
  Funktionen und Möglichkeiten von Matplotlib behandelt, wie das
  Erstellen verschiedener Arten von Plots, das Anpassen von Achsen und
  Beschriftungen und das Arbeiten mit verschiedenen Diagrammtypen.

** 1. Einführung in Matplotlib
:PROPERTIES:
:CUSTOM_ID: 1-einführung-in-matplotlib
:END:
Matplotlib ist eine der bekanntesten und am häufigsten verwendeten
Bibliotheken für die Datenvisualisierung in Python. Sie ermöglicht es,
eine Vielzahl von Diagrammen und Plots zu erstellen, um Daten auf eine
visuell ansprechende und leicht verständliche Weise darzustellen. Die
Visualisierung von Daten ist ein wichtiger Aspekt der Datenanalyse, da
sie es ermöglicht, Muster, Trends und Beziehungen in den Daten zu
erkennen, die sonst schwer zu identifizieren wären.

Die Matplotlib-Bibliothek ist sehr flexibel und ermöglicht eine hohe
Kontrolle über alle Aspekte eines Plots oder Diagramms. Sie kann sowohl
für einfache Plots als auch für komplexe Visualisierungen verwendet
werden und ist daher ein wichtiges Werkzeug für jeden, der mit Daten in
Python arbeitet.

Um Matplotlib zu verwenden, müssen wir es zunächst importieren. In der
Regel wird es unter dem Alias =plt= importiert, was eine gängige
Konvention in der Python-Community ist.

#+begin_src
# Importieren der Matplotlib-Bibliothek
import matplotlib.pyplot as plt
#+end_src

Nachdem wir Matplotlib importiert haben, können wir mit der Erstellung
von Plots beginnen. Ein einfacher Plot kann mit der Funktion =plot()=
erstellt werden, die eine Liste von Werten erwartet. Nachdem der Plot
erstellt wurde, können wir ihn mit der Funktion =show()= anzeigen.

#+begin_src
# Einfacher Plot
plt.plot([1, 2, 3, 4, 5])
plt.show()
#+end_src

Dieser Code erstellt einen einfachen Linienplot mit den Werten 1 bis 5
auf der y-Achse. Da wir keine Werte für die x-Achse angegeben haben,
verwendet Matplotlib die Indizes der Liste als x-Werte, d.h. die x-Achse
geht von 0 bis 4.

#+begin_src
# Importieren der Matplotlib-Bibliothek
import matplotlib.pyplot as plt
#+end_src

#+begin_src
# Einfacher Plot
plt.plot([1, 2, 1, 4, 3])
plt.show()
#+end_src

[[file:40893d1ef98a94ed83e986dd38841b7ac9d09b64.png]]

*** Aufgabe 1: Ein W plotten
:PROPERTIES:
:CUSTOM_ID: aufgabe-1-ein-w-plotten
:END:
Erstellen Sie einen einfachen Plot der die Form eines =W= hat. Verwenden
Sie die Funktionen =plot()= und =show()= von Matplotlib.

#+begin_src
#+end_src

** Grundkonzepte von Matplotlib
:PROPERTIES:
:CUSTOM_ID: grundkonzepte-von-matplotlib
:END:

- *Visualisierungen*: Eine umfangreiche Bibliothek für die Erstellung
  statischer, animierter und interaktiver Visualisierungen in Python.
- *Hierarchisches Modell*: Matplotlib-Visualisierungen basieren auf
  einem hierarchischen Modell mit mehreren ineinander verschachtelten
  Python-Objekten.
- *Figure*: Das oberste Level-Objekt in der Hierarchie, kann mehrere
  Diagramme (Achsen) enthalten.
- *Axes*: Ein Diagramm oder Zeichenbereich mit Koordinaten (Achsen), in
  dem Punkte markiert werden können. Jede Figur kann mehrere Diagramme
  enthalten.
- *Plot*: Eine Linie oder Sammlung von Punkten, die in einem Diagramm
  dargestellt werden. Ein Diagramm kann mehrere Plots enthalten.
- *Erstellen einer Figur und Achsen*: Mit =plt.subplots()= wird eine
  neue Figur und ein Achsenobjekt erstellt, die dann angezeigt werden
  können.

Matplotlib ist eine umfangreiche Bibliothek für die Erstellung
statischer, animierter und interaktiver Visualisierungen in Python. Sie
wurde von John D. Hunter entwickelt und ist seitdem eine der am
häufigsten verwendeten Datenvisualisierungstools in der
wissenschaftlichen Python-Community. Matplotlib bietet eine Vielzahl von
Funktionen und Anpassungsmöglichkeiten, um Daten in verschiedenen
Formaten und Perspektiven darzustellen.

Um effektiv mit Matplotlib arbeiten zu können, ist es wichtig, einige
grundlegende Konzepte zu verstehen. Die Visualisierungen in Matplotlib
basieren auf einem hierarchischen Modell, das aus mehreren ineinander
verschachtelten Python-Objekten besteht. Die drei wichtigsten sind:

1. *Figure*: Dies ist das oberste Level-Objekt in dieser Hierarchie.
   Eine Figur kann mehrere Diagramme (auch als Achsen bezeichnet)
   enthalten. Sie enthält alle Child-Achsen und bietet auch Funktionen
   zur Erstellung von Achsen.

2. *Axes*: Dies ist das, was wir als ein Diagramm bezeichnen. Ein
   Diagramm ist ein Zeichenbereich mit Koordinaten (in Form von Achsen),
   in dem Punkte markiert werden können. Jede Figur kann mehrere
   Diagramme enthalten, aber ein Diagramm ist immer an eine Figur
   gebunden.

3. *Plot*: Ein Plot ist eine Linie oder eine Sammlung von Punkten, die
   in einem Diagramm dargestellt werden. Ein Diagramm kann mehrere Plots
   enthalten.

In Matplotlib gibt es zwei verschiedene Wege, um Diagramme zu erstellen:
die pyplot API und die objektorientierte API. Die pyplot API ist
einfacher zu verwenden und daher gut für einfache Plots geeignet,
während die objektorientierte API mehr Kontrolle und Flexibilität
bietet, insbesondere wenn man mit mehreren Figuren und Achsen arbeitet.

[[file:image.png]]

Schematische Darstellung einer =Figure= mit einer =Axes=.

[[file:image.png]]

Schematische Darstellung einer =Figure= mit mehreren =Axes=.

[[file:image.png]]

Schematische Darstellung einer =Figure= mit einer =Axes= inklusive der
Elemente =Axis=, =Line=, =Ticks= und =Tick Labels=.

#+begin_src
# Erstellen einer Figure und mit 4 leeren Axes (Subplots)
fig, ax = plt.subplots(2,2)

# Zeigen der leeren Figure und Axes
plt.show()
#+end_src

[[file:2e06ee760cedb85f8a46034eb9b3b4a7f5852df0.png]]

#+begin_src
# Erstellen einer Figur und Achsen
fig, ax = plt.subplots()

# Hinzufügen von Titeln zur Figure und Axes
fig.suptitle('Meine erste Figure')
ax.set_title('Meine erste Axes')

# Zeigen der Figure und Axes
plt.show()
#+end_src

[[file:213f0843a7554463083e8ffd4a4e3c155daf312f.png]]

*** Aufgabe 2: Figures, Axes und Titles
:PROPERTIES:
:CUSTOM_ID: aufgabe-2-figures-axes-und-titles
:END:
Erstellen Sie eine Figure mit 4 Subplots (2x2) und fügen Sie jedem
Subplot einen Titel hinzu. Verwenden Sie die Funktion =plt.subplots()=
um die Figure und die Axes zu erstellen. Verwenden Sie die Funktion
=ax.set_title()= um den Titel zu setzen.

Sollten Ihre Title in die Axes hineinragen, können Sie die Methode
=tight_layout()= auf Ihr Figure Objekt anwenden (bspw.
=fig.tight_layout()=).

#+begin_src
#+end_src

** Erstellen einfacher Plots
:PROPERTIES:
:CUSTOM_ID: erstellen-einfacher-plots
:END:

- *Linienplot*: Einfache Art von Plot, nützlich zur Darstellung von
  Trends über die Zeit.
  - Verwendung der Funktion =plot()= zum Erstellen eines Linienplots.
  - =show()= wird verwendet, um den Plot anzuzeigen.
- *Balkendiagramm*: Nützlich zur Darstellung kategorialer Daten.
  - Verwendung der Funktion =bar()= zum Erstellen eines Balkendiagramms.
  - =show()= wird verwendet, um den Plot anzuzeigen.

*** Linienplot
:PROPERTIES:
:CUSTOM_ID: linienplot
:END:
Ein Linienplot ist eine der einfachsten Arten von Plots, die Sie
erstellen können. Es ist besonders nützlich, um Trends über die Zeit
darzustellen. Hier ist ein einfaches Beispiel, wie man einen Linienplot
erstellt:

#+begin_src
import matplotlib.pyplot as plt

# Daten für die x- und y-Achse
x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]

# Erstellen des Plots
plt.plot(x, y)

# Anzeigen des Plots
plt.show()
#+end_src

In diesem Code erstellen wir zuerst Daten für die x- und y-Achse. Dann
verwenden wir die Funktion =plot()= von Matplotlib, um einen Linienplot
zu erstellen. Schließlich verwenden wir =show()=, um den Plot
anzuzeigen.

#+begin_src
import matplotlib.pyplot as plt

# Daten für die x- und y-Achse
x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]

# Erstellen des Plots
plt.plot(x, y)

# Anzeigen des Plots
plt.show()
#+end_src

[[file:9af7441a6f2bb0bac1a39c644634f23a92d3975d.png]]

*** Balkendiagramm
:PROPERTIES:
:CUSTOM_ID: balkendiagramm
:END:
Ein Balkendiagramm ist nützlich, um kategoriale Daten darzustellen. Hier
ist ein einfaches Beispiel, wie man ein Balkendiagramm erstellt:

#+begin_src
import matplotlib.pyplot as plt

# Daten für die x- und y-Achse
x = ['A', 'B', 'C', 'D', 'E']
y = [3, 7, 2, 5, 8]

# Erstellen des Plots
plt.bar(x, y)

# Anzeigen des Plots
plt.show()
#+end_src

In diesem Code erstellen wir zuerst Daten für die x- und y-Achse. Dann
verwenden wir die Funktion =bar()= von Matplotlib, um ein Balkendiagramm
zu erstellen. Schließlich verwenden wir =show()=, um den Plot
anzuzeigen.

#+begin_src
import matplotlib.pyplot as plt

# Daten für die x- und y-Achse
x = ['A', 'B', 'C', 'D', 'E']
y = [3, 7, 2, 5, 8]

# Erstellen des Plots
plt.bar(x, y)

# Anzeigen des Plots
plt.show()
#+end_src

[[file:63b72a88eaa219097819d7c737df72f23283235f.png]]

** Anpassen von Achsen und Beschriftungen
:PROPERTIES:
:CUSTOM_ID: anpassen-von-achsen-und-beschriftungen
:END:

- *Anpassen der Achsen*: Definiert den Bereich der Daten, der in einem
  Plot dargestellt wird.
  - Funktionen =xlim()= und =ylim()= werden verwendet, um die Grenzen
    der x- und y-Achsen einzustellen.
- *Hinzufügen von Beschriftungen*: Hilft den Betrachtern, die
  dargestellten Daten zu verstehen.
  - Funktion =title()= zum Hinzufügen eines Titels.
  - Funktionen =xlabel()= und =ylabel()= zum Hinzufügen von
    Achsenlabels.
  - Funktion =legend()= zum Hinzufügen einer Legende.
- Beschriftungen und Achsenanpassungen sind wesentliche Schritte zur
  Erstellung aussagekräftiger und leicht verständlicher
  Datenvisualisierungen.
- *Numpy* Die Bibliothek Numpy wird häufig in Kombination mit Matplotlib
  verwendet, um Daten zu generieren. Wir können beispielsweise eine
  Sinus- oder Cosinus-Funktion erstellen und diese dann plotten.
  Importieren Sie dazu die Bibliothek Numpy wie folgt:
  =import numpy as np=. Anschließend können Sie die bspw. Funktionen
  =np.sin()= und =np.cos()= verwenden, um die Sinus- und Cosinus-Werte
  zu berechnen.

*** Anpassen der Achsen
:PROPERTIES:
:CUSTOM_ID: anpassen-der-achsen
:END:
Die Achsen eines Plots definieren den Bereich der Daten, der dargestellt
wird. Manchmal möchten wir vielleicht den Bereich der Achsen anpassen,
um bestimmte Aspekte unserer Daten hervorzuheben. Mit Matplotlib können
wir die Funktionen =xlim()= und =ylim()= verwenden, um die Grenzen der
x- und y-Achsen einzustellen.

#+begin_src
import matplotlib.pyplot as plt
import numpy as np

# Daten generieren
x = np.linspace(0, 6, 100) # 100 Werte von 0 bis 6 generieren
y = np.sin(x) # Sinus-Funktion

# Plot erstellen
plt.plot(x, y)

# Achsen anpassen
plt.xlim(-1, 7)
plt.ylim(-1.5, 1.5)

# Plot anzeigen
plt.show()
#+end_src

In diesem Beispiel haben wir den Bereich der x-Achse auf -1 bis 7 und
den der y-Achse auf -1.5 bis 1.5 beschränkt.

#+begin_src
import matplotlib.pyplot as plt
import numpy as np

# Daten generieren
x = np.linspace(0, 6, 100) # 100 Werte von 0 bis 6 generieren
y = np.sin(x) # Sinus-Funktion

# Plot erstellen
plt.plot(x, y)

# Achsen anpassen
plt.xlim(-1, 7)
plt.ylim(-1.5, 1.5)

# Plot anzeigen
plt.show()
#+end_src

[[file:c74ffa84bcdd1577b8849cd74e37ae9a19a8d847.png]]

*** Hinzufügen von Beschriftungen
:PROPERTIES:
:CUSTOM_ID: hinzufügen-von-beschriftungen
:END:
Beschriftungen sind ein wichtiger Bestandteil einer Datenvisualisierung,
da sie den Betrachtern helfen, die dargestellten Daten zu verstehen.
Matplotlib bietet Funktionen zum Hinzufügen von Titeln (=title()=),
Achsenlabels (=xlabel()= und =ylabel()=) und Legenden (=legend()=).

#+begin_src
# Daten generieren
x = np.linspace(0, 6, 100) # 100 Werte von 0 bis 6 generieren
y = np.sin(x) # Sinus-Funktion

# Plot erstellen
plt.plot(x, y)

# Achsen anpassen
plt.xlim(-1, 7)
plt.ylim(-1.5, 1.5)

# Beschriftungen hinzufügen
plt.title('Sinusfunktion')
plt.xlabel('x')
plt.ylabel('sin(x)')
plt.legend()

# Plot anzeigen
plt.show()
#+end_src

In diesem Beispiel haben wir einen Titel, Achsenlabels und eine Legende
zu unserem Plot hinzugefügt. Die Legende verwendet das Label, das wir
beim Erstellen des Plots angegeben haben.

#+begin_src
# Daten generieren
x = np.linspace(0, 6, 100) # 100 Werte von 0 bis 6 generieren
y = np.sin(x) # Sinus-Funktion

# Plot erstellen
plt.plot(x, y)

# Achsen anpassen
plt.xlim(-1, 7)
plt.ylim(-1.5, 1.5)

# Beschriftungen hinzufügen
plt.title('Sinusfunktion') # Titel
plt.xlabel('x') # Beschriftung x-Achse
plt.ylabel('sin(x)') # Beschriftung y-Achse
plt.legend(['sin(x)']) # Legende

# Plot anzeigen
plt.show()
#+end_src

[[file:4d74d5771112dd51e18d1458d932a4583582c66c.png]]

* Aufgabe 3: Aktienkurs plotten
:PROPERTIES:
:CUSTOM_ID: aufgabe-3-aktienkurs-plotten
:END:
Erstellen Sie einen Linienplot, der die Entwicklung der Aktienpreise
eines fiktiven Unternehmens über eine Woche darstellt. Die Aktienpreise
sind wie folgt: [120, 125, 130, 128, 132].

Verwenden Sie die Methoden =xlabel(str)= und =ylabel(str)= um der
horizontalen und der vertikalen Achse einen Titel zuzuweisen.

#+begin_src
#+end_src

*** Aufgabe 4: Balkendiagramm mit mehreren Balken
:PROPERTIES:
:CUSTOM_ID: aufgabe-4-balkendiagramm-mit-mehreren-balken
:END:
Erstellen Sie ein Balkendiagramm, das die Anzahl der Studierenden in
verschiedenen Studiengängen an einer Universität darstellt. Die
Studiengänge und die Anzahl der Studierenden sind wie folgt:
{'Informatik': 200, 'Maschinenbau': 300, 'Wirtschaft': 400, 'Design':
100}. Verwenden Sie die Methode =plt.bar()= um das Balkendiagramm zu
erstellen. Fügen Sie dem Diagramm einen Titel und Achsenbeschriftungen
hinzu.

#+begin_src
#+end_src

** Arbeiten mit verschiedenen Diagrammtypen
:PROPERTIES:
:CUSTOM_ID: arbeiten-mit-verschiedenen-diagrammtypen
:END:

- *Histogramme*: Diagramme, die die Häufigkeitsverteilung eines
  Datensatzes darstellen. Sie sind effektive Werkzeuge zur
  Visualisierung der Verteilung von Daten. In Matplotlib wird die
  Funktion =hist()= zur Erstellung von Histogrammen verwendet.

- *Scatter-Plots*: Diagramme, die Punkte auf einem Koordinatensystem
  darstellen. Sie sind nützlich, um die Beziehung zwischen zwei
  Variablen zu visualisieren. In Matplotlib wird die Funktion
  =scatter()= zur Erstellung von Scatter-Plots verwendet.

- *Boxplots*: Diagramme, die die statistische Verteilung eines
  Datensatzes darstellen. Sie zeigen das Minimum, das erste Quartil, den
  Median, das dritte Quartil und das Maximum der Daten. In Matplotlib
  wird die Funktion =boxplot()= zur Erstellung von Boxplots verwendet.

- *Auswahl des richtigen Diagrammtyps*: Jeder Diagrammtyp hat seine
  eigenen Stärken und ist für bestimmte Arten von Daten und
  Fragestellungen geeignet. Es ist wichtig, den richtigen Diagrammtyp
  für Ihre Daten und Ihre spezifischen Bedürfnisse auszuwählen.

*** Histogramme
:PROPERTIES:
:CUSTOM_ID: histogramme
:END:
Ein Histogramm ist ein Diagramm, das die Häufigkeitsverteilung eines
Datensatzes darstellt. Es ist ein effektives Werkzeug, um die Verteilung
von Daten zu visualisieren. In Matplotlib können wir die Funktion
=hist()= verwenden, um ein Histogramm zu erstellen.

#+begin_src
import matplotlib.pyplot as plt
import numpy as np

# Erstellen Sie zufällige Daten
data = np.random.randn(1000)

# Erstellen Sie ein Histogramm
plt.hist(data, bins=30, alpha=0.5, color='g')
plt.show()
#+end_src

In diesem Code erstellen wir zunächst einen Datensatz mit 1000
zufälligen Werten. Dann verwenden wir die Funktion =hist()=, um ein
Histogramm zu erstellen. Der Parameter =bins= bestimmt die Anzahl der
Intervalle, in die die Daten aufgeteilt werden, und =alpha= bestimmt die
Transparenz der Balken.

#+begin_src
# Histogramm erstellen

# Erstellen Sie zufällige Daten
data = np.random.randn(1000)

# Erstellen Sie ein Histogramm
plt.hist(data, bins=30, alpha=0.5, color='g')
plt.show()
#+end_src

[[file:cc934952cf3bfc49d3d3c6c422e15aa4de05c258.png]]

*** Scatter-Plots
:PROPERTIES:
:CUSTOM_ID: scatter-plots
:END:
Ein Scatter-Plot ist ein Diagramm, das Punkte auf einem
Koordinatensystem darstellt. Es ist nützlich, um die Beziehung zwischen
zwei Variablen zu visualisieren. In Matplotlib können wir die Funktion
=scatter()= verwenden, um ein Scatter-Plot zu erstellen.

#+begin_src
# Erstellen Sie zufällige Daten
x = np.random.randn(100)
y = np.random.randn(100)

# Erstellen Sie ein Scatter-Plot
plt.scatter(x, y, alpha=0.5)
plt.show()
#+end_src

In diesem Code erstellen wir zwei Datensätze =x= und =y= mit jeweils 100
zufälligen Werten. Dann verwenden wir die Funktion =scatter()=, um ein
Scatter-Plot zu erstellen.

#+begin_src
# Scatter Plot erstellen

# Erstellen Sie zufällige Daten
x = np.random.randn(100)
y = np.random.randn(100)

# Erstellen Sie ein Scatter-Plot
plt.scatter(x, y, alpha=0.5)
plt.show()
#+end_src

[[file:f9d22b6308332c5832cbd915c7b7a2d1a27db931.png]]

** Boxplots
:PROPERTIES:
:CUSTOM_ID: boxplots
:END:
Ein Boxplot ist ein Diagramm, das die statistische Verteilung eines
Datensatzes darstellt. Es zeigt das Minimum, das erste Quartil, den
Median, das dritte Quartil und das Maximum der Daten. In Matplotlib
können wir die Funktion =boxplot()= verwenden, um ein Boxplot zu
erstellen.

#+begin_src
# Erstellen Sie zufällige Daten
data = [np.random.randn(1000), 5 * np.random.randn(1000), 10 * np.random.rand(1000)]

# Erstellen Sie ein Boxplot
plt.boxplot(data, vert=False, patch_artist=True)
plt.show()
#+end_src

In diesem Code erstellen wir drei Datensätze mit jeweils 1000 zufälligen
Werten. Dann verwenden wir die Funktion =boxplot()=, um ein Boxplot zu
erstellen. Der Parameter =vert=False= legt fest, dass das Boxplot
horizontal angezeigt wird, und =patch_artist=True= ermöglicht die
Färbung der Boxen.

#+begin_src
# Boxplot erstellen

# Erstellen von drei zufälligen Datensätzen mit unterschiedlichen Verteilungen
data = [np.random.randn(1000), 5 * np.random.randn(1000), 10 * np.random.rand(1000)]

# Erstellen des Boxplots mit vertikaler Ausrichtung und farbigen Boxen
plt.boxplot(data, vert=False, patch_artist=True)
plt.show()
#+end_src

[[file:a60ada178da52f3399e181fd329109e9a993064d.png]]

*** Aufgabe 5: Histogram
:PROPERTIES:
:CUSTOM_ID: aufgabe-5-histogram
:END:
Erstellen Sie ein Histogramm für einen Datensatz, der 5000 zufällige
Werte enthält. Verwenden Sie 50 Balken (=bins=) und stellen Sie das
Histogramm in der Farbe Blau dar.

Nutzen Sie für die Datengenerierung die Methode randn() aus np.random
=np.random.randn()= und übergeben Sie die Anzal der Werte als Parameter.

#+begin_src
#+end_src

*** Aufgabe 6: Scatter Plot
:PROPERTIES:
:CUSTOM_ID: aufgabe-6-scatter-plot
:END:
Erstellen Sie ein Scatter-Plot für zwei Datensätze, die jeweils 200
zufällige Werte enthalten. Stellen Sie die Punkte in der Farbe Rot dar.

Nutzen Sie für die Datengenerierung die Methode randn() aus np.random
=np.random.randn()= und übergeben Sie die Anzal der Werte als Parameter.

#+begin_src
#+end_src

** Visualisierung von Pandas DataFrames
:PROPERTIES:
:CUSTOM_ID: visualisierung-von-pandas-dataframes
:END:

- *Pandas und Matplotlib*: Pandas ist eine leistungsstarke Bibliothek
  für die Datenmanipulation und -analyse in Python. Matplotlib ist eine
  ausgezeichnete Bibliothek für die Datenvisualisierung in Python. Beide
  können nahtlos integriert werden, um Daten in Pandas DataFrames zu
  visualisieren.
- *Pandas DataFrames*: DataFrames sind zweidimensionale,
  größenveränderliche und potenziell heterogene Tabellendatenstrukturen.
  Sie sind eine der wichtigsten Funktionen von Pandas.
- *Erstellen von Plots aus DataFrames*: Pandas DataFrames haben eine
  eingebaute =plot()= Funktion, die eine einfache Schnittstelle zur
  Erstellung von Diagrammen bietet. Die =plot()= Funktion ist ein
  Wrapper um die Matplotlib =pyplot.plot()= Funktion.
- *Anpassen von Plots*: Die =plot()= Funktion bietet viele Optionen zur
  Anpassung des Aussehens des Diagramms, einschließlich der Farbe und
  des Stils der Linie, dem Hinzufügen von Gitterlinien und dem Anpassen
  der Achsenbeschriftungen.
- *Integration von Matplotlib und Pandas*: Die Integration von
  Matplotlib und Pandas ermöglicht es uns, die leistungsstarken
  Datenmanipulationsfunktionen von Pandas zu nutzen und gleichzeitig die
  flexiblen Visualisierungsoptionen von Matplotlib zu nutzen, um unsere
  Daten effektiv darzustellen.

*** Erstellen von Plots aus DataFrames
:PROPERTIES:
:CUSTOM_ID: erstellen-von-plots-aus-dataframes
:END:
Pandas DataFrames haben eine eingebaute =plot()= Funktion, die eine
einfache Schnittstelle zur Erstellung von Diagrammen bietet. Die
=plot()= Funktion ist eine Wrapper-Funktion um die Matplotlib
=pyplot.plot()= Funktion, die eine flexible Schnittstelle für die
Erstellung aller Arten von Plots bietet.

Hier ist ein einfaches Beispiel, wie man ein Liniendiagramm aus einem
DataFrame erstellt:

#+begin_src
import pandas as pd
import matplotlib.pyplot as plt

# Erstellen eines einfachen DataFrame
data = {'Jahr': [2015, 2016, 2017, 2018, 2019],
        'Verkauf': [200, 250, 330, 350, 370]}
df = pd.DataFrame(data)

# Erstellen eines Liniendiagramms
df.plot(x='Jahr', y='Verkauf', kind='line')
plt.show()
#+end_src

In diesem Beispiel erstellen wir zuerst einen DataFrame mit zwei
Spalten: 'Jahr' und 'Verkauf'. Dann rufen wir die =plot()= Funktion auf
dem DataFrame auf und geben die Spaltennamen für die x- und y-Achsen an.
Der Parameter =kind= bestimmt den Typ des Diagramms, in diesem Fall ein
Liniendiagramm.

#+begin_src
import pandas as pd
import matplotlib.pyplot as plt

# Erstellen eines einfachen DataFrame
data = {'Jahr': [2015, 2016, 2017, 2018, 2019],
        'Verkauf': [200, 250, 330, 350, 370]}
df = pd.DataFrame(data)

# Erstellen eines Liniendiagramms
df.plot(x='Jahr', y='Verkauf', kind='line')
plt.show()
#+end_src

[[file:ec0d003f9e0dd320ac3e4c39a88edac0f8d370c9.png]]

*** Anpassen von Pandas Plots
:PROPERTIES:
:CUSTOM_ID: anpassen-von-pandas-plots
:END:
Die =plot()= Funktion bietet viele Optionen zur Anpassung des Aussehens
des Diagramms. Wir können zum Beispiel die Farbe und den Stil der Linie
ändern, Gitterlinien hinzufügen und die Achsenbeschriftungen anpassen.

#+begin_src
# Anpassen des Diagramms
df.plot(x='Jahr', y='Verkauf', kind='line', color='red', linestyle='--', grid=True)
plt.title('Verkauf über die Jahre')
plt.xlabel('Jahr')
plt.ylabel('Verkauf')
plt.show()
#+end_src

In diesem Beispiel haben wir die Farbe der Linie auf Rot und den
Linienstil auf gestrichelt geändert. Wir haben auch Gitterlinien
hinzugefügt und die Achsenbeschriftungen mit den Funktionen =title()=,
=xlabel()= und =ylabel()= von Matplotlib eingestellt.

#+begin_src
df.plot(x='Jahr', y='Verkauf', kind='line', color='red', linestyle='--', grid=True)
plt.title('Verkauf über die Jahre')
plt.xlabel('Jahr')
plt.ylabel('Verkauf')
plt.show()
#+end_src

[[file:94b5239ce167a80b2fabfc0774e1af63bd9a9d58.png]]

* Aufgabe 7: Pandas-Plot
:PROPERTIES:
:CUSTOM_ID: aufgabe-7-pandas-plot
:END:
Erstellen Sie einen DataFrame, der die durchschnittlichen Temperaturen
(in Grad Celsius) für die vier Jahreszeiten in den Jahren 2015 bis 2020
enthält. Visualisieren Sie die Daten in einem Liniendiagramm. Erstellen
Sie alle notwendigen Beschriftungen und passen Sie die Farben und
Linienstile an.

#+begin_src
#+end_src

** Stilisierung von Plots
:PROPERTIES:
:CUSTOM_ID: stilisierung-von-plots
:END:

- *Stilisierung von Plots*: Verbessert die Lesbarkeit und Ästhetik der
  Plots und lenkt die Aufmerksamkeit auf bestimmte Datenaspekte.
- *Farben*: Können verwendet werden, um unterschiedliche Datenkategorien
  zu unterscheiden, Aufmerksamkeit auf bestimmte Datenpunkte zu lenken
  oder den Plot ästhetisch ansprechender zu machen.
- *Linienstile*: Matplotlib bietet verschiedene Stile, einschließlich
  durchgezogener, gestrichelter, gepunkteter Linien und mehr.
- *Schriftarten*: Die Schriftart, Schriftgröße, Schriftfarbe und andere
  Aspekte von Textelementen in einem Plot können angepasst werden.
- *Stylesheets*: Vordefinierte Stylesheets in Matplotlib können
  verwendet werden, um das Aussehen von Plots schnell zu ändern. Es ist
  auch möglich, eigene Stylesheets für konsistente Darstellungen zu
  erstellen.
- *Designprinzipien*: Ein gutes Verständnis für Designprinzipien und die
  Bedeutung der darzustellenden Daten ist wichtig für die effektive
  Stilisierung von Plots.

*** Farben
:PROPERTIES:
:CUSTOM_ID: farben
:END:
Die Farbe ist ein wichtiger Aspekt bei der Gestaltung von Plots. Sie
kann verwendet werden, um unterschiedliche Kategorien von Daten zu
unterscheiden, die Aufmerksamkeit auf bestimmte Datenpunkte zu lenken
oder einfach nur um den Plot ästhetisch ansprechender zu machen. In
Matplotlib können wir die Farbe von fast jedem Element eines Plots
ändern, einschließlich Linien, Balken, Hintergrund, Text usw.

#+begin_src
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 100)
y = np.sin(x)

plt.plot(x, y, color='red')  # Ändert die Farbe der Linie in Rot
plt.show()
#+end_src

*** Linienstile
:PROPERTIES:
:CUSTOM_ID: linienstile
:END:
Neben der Farbe können wir auch den Stil der Linien in einem Plot
ändern. Matplotlib bietet verschiedene Linienstile, einschließlich
durchgezogener, gestrichelter, gepunkteter Linien und mehr.

#+begin_src
plt.plot(x, y, linestyle='--')  # Ändert den Linienstil in gestrichelt
plt.show()
#+end_src

*** Schriftarten
:PROPERTIES:
:CUSTOM_ID: schriftarten
:END:
Die Schriftart von Textelementen in einem Plot, wie Titel,
Achsenbeschriftungen und Legenden, kann ebenfalls angepasst werden. Wir
können die Schriftart, Schriftgröße, Schriftfarbe und andere Aspekte
ändern.

#+begin_src
plt.plot(x, y)
plt.title('Sinuswelle', fontsize=20, color='blue')  # Ändert die Schriftgröße und Farbe des Titels
plt.show()
#+end_src

*** Stylesheets
:PROPERTIES:
:CUSTOM_ID: stylesheets
:END:
Matplotlib bietet eine Reihe von vordefinierten Stylesheets, die wir
verwenden können, um das Aussehen unserer Plots schnell zu ändern. Ein
Stylesheet definiert eine Reihe von Stileinstellungen, einschließlich
Farben, Linienstile, Hintergrundfarbe und mehr.

#+begin_src
plt.style.use('ggplot')  # Verwendet das 'ggplot' Stylesheet
plt.plot(x, y)
plt.show()
#+end_src

Wir können auch unser eigenes Stylesheet erstellen und es für
konsistente Darstellungen in unseren Plots verwenden. Dies ist besonders
nützlich, wenn wir eine bestimmte Stilrichtlinie für alle unsere Plots
beibehalten möchten.

** Interaktive Plots
:PROPERTIES:
:CUSTOM_ID: interaktive-plots
:END:

- *Interaktive Plots*: Dynamische Visualisierungen, die vom Benutzer
  manipuliert werden können, um verschiedene Aspekte der Daten zu
  untersuchen.
- *Nützlichkeit*: Besonders hilfreich bei der Arbeit mit großen oder
  komplexen Datensätzen, bei denen es schwierig sein kann, alle
  relevanten Informationen auf einmal darzustellen.
- *Widgets*: Interaktive Elemente wie Schieberegler, Schaltflächen oder
  Dropdown-Menüs, die es dem Benutzer ermöglichen, verschiedene
  Parameter der Visualisierung zu steuern.
- *Erstellung interaktiver Plots*: Verwendung der =pyplot=-Funktion
  =plot= und dann Aufruf der Funktion =show=, um das Diagramm
  anzuzeigen.
- *Interaktiver Modus*: Aktiviert mit =plt.ion()=, ermöglicht
  Manipulation des Plots.
- *Interaktivität in Jupyter Notebooks*: Verwendung des
  =notebook=-Backends durch Aufrufen von =%matplotlib notebook= am
  Anfang des Notebooks.
- *Vorteile interaktiver Plots*: Ermöglichen tieferes Eintauchen in die
  Daten und Untersuchung verschiedener Aspekte, die in einem statischen
  Plot möglicherweise nicht sofort ersichtlich sind.

Interaktive Plots sind eine leistungsstarke Funktion von Matplotlib, die
es ermöglicht, dynamische Visualisierungen zu erstellen. Im Gegensatz zu
statischen Plots, die einmal gerendert und dann unverändert bleiben,
können interaktive Plots vom Benutzer manipuliert werden, um
verschiedene Aspekte der Daten zu untersuchen. Dies kann besonders
nützlich sein, wenn man mit großen oder komplexen Datensätzen arbeitet,
bei denen es schwierig sein kann, alle relevanten Informationen auf
einmal darzustellen.

Die Erstellung interaktiver Plots in Matplotlib erfolgt durch die
Verwendung von Widgets. Widgets sind interaktive Elemente wie
Schieberegler, Schaltflächen oder Dropdown-Menüs, die es dem Benutzer
ermöglichen, verschiedene Parameter der Visualisierung zu steuern.

Zum Beispiel könnte man einen Schieberegler verwenden, um den
dargestellten Zeitraum in einem Zeitreihendiagramm zu ändern, oder eine
Dropdown-Liste, um zwischen verschiedenen Kategorien in einem
Balkendiagramm zu wechseln.

Um ein einfaches interaktives Diagramm zu erstellen, können wir die
=pyplot=-Funktion =plot= verwenden und dann die Funktion =show=
aufrufen, um das Diagramm anzuzeigen. Hier ist ein einfaches Beispiel:

#+begin_src
import matplotlib.pyplot as plt
import numpy as np

# Daten generieren
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Plot erstellen
plt.plot(x, y)

# Interaktiven Modus aktivieren
plt.ion()

# Plot anzeigen
plt.show()
#+end_src

In diesem Code wird zunächst ein einfacher Sinus-Plot erstellt. Dann
wird der interaktive Modus mit =plt.ion()= aktiviert. Schließlich wird
der Plot mit =plt.show()= angezeigt.

Jetzt können wir den Plot manipulieren, indem wir zum Beispiel die Zoom-
und Schwenkfunktionen verwenden, die in der Werkzeugleiste am unteren
Rand des Fensters verfügbar sind.

#+begin_src
import matplotlib.pyplot as plt
import numpy as np

# Daten generieren
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Plot erstellen
plt.plot(x, y)

# Interaktiven Modus aktivieren
plt.ion()

# Plot anzeigen
plt.show()
#+end_src

[[file:a67246111bba81554124f481db9a85bd8cf962a1.png]]

Es ist zu beachten, dass die Interaktivität in Jupyter Notebooks etwas
anders funktioniert als in einem normalen Python-Skript. In einem
Notebook müssen wir die =notebook=-Backend verwenden, um interaktive
Plots zu erstellen. Dies kann durch Aufrufen von =%matplotlib notebook=
am Anfang des Notebooks erreicht werden.

#+begin_src
%matplotlib notebook
import matplotlib.pyplot as plt
import numpy as np

# Daten generieren
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Plot erstellen
plt.plot(x, y)

# Plot anzeigen
plt.show()
#+end_src

In diesem Fall wird der Plot direkt im Notebook angezeigt und kann dort
manipuliert werden.

#+begin_src
%matplotlib notebook
import matplotlib.pyplot as plt
import numpy as np

# Daten generieren
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Plot erstellen
plt.plot(x, y)

# Plot anzeigen
plt.show()
#+end_src

#+begin_example
<IPython.core.display.Javascript object>
#+end_example

#+begin_example
<IPython.core.display.HTML object>
#+end_example

*** Aufgabe 8: Interaktive Visualisierung
:PROPERTIES:
:CUSTOM_ID: aufgabe-8-interaktive-visualisierung
:END:
Erstellen Sie ein interaktives Scatter-Plot mit zufällig generierten
Datenpunkten. Aktivieren Sie den interaktiven Modus und zeigen Sie das
Diagramm an.

#+begin_src
#+end_src

** Best Practices beim Plotting
:PROPERTIES:
:CUSTOM_ID: best-practices-beim-plotting
:END:

- *Auswahl des richtigen Diagrammtyps*: Wählen Sie den Diagrammtyp, der
  am besten zu Ihren Daten und Ihrer Fragestellung passt.
- *Vermeidung von überflüssigen Informationen*: Halten Sie Ihre
  Diagramme so einfach wie möglich und vermeiden Sie unnötige
  Dekorationen.
- *Verwendung von Farben und Markierungen*: Nutzen Sie Farben und
  Markierungen, um verschiedene Datenpunkte oder -reihen zu
  unterscheiden, aber verwenden Sie sie mit Bedacht.
- *Beschriftung von Achsen und Titeln*: Geben Sie Ihren Diagrammen immer
  klare und präzise Achsenbeschriftungen und Titel.
- *Fazit*: Die Erstellung von effektiven und ansprechenden Plots ist
  eine Kunst, die sowohl technisches Wissen als auch ein Verständnis für
  Designprinzipien erfordert.

** *Fortgeschrittene Visualisierungstechniken
:PROPERTIES:
:CUSTOM_ID: fortgeschrittene-visualisierungstechniken
:END:

- *3D-Plotting*: Matplotlib bietet Funktionen für das 3D-Plotting, die
  es ermöglichen, dreidimensionale Diagramme zu erstellen. Dies ist
  nützlich für die Visualisierung von Daten mit mehr als zwei
  Dimensionen.
- *Animationen*: Mit der =FuncAnimation=-Klasse von Matplotlib können
  animierte Diagramme erstellt werden. Hierbei wird eine Funktion
  definiert, die bei jedem Frame der Animation aufgerufen wird.
- *Subplots*: Mit Subplots können mehrere Diagramme in einer einzigen
  Figur dargestellt werden. Dies ist hilfreich, wenn mehrere verwandte
  Datenreihen verglichen werden sollen.
- *Wahl der Visualisierungstechnik*: Die Wahl der Visualisierungstechnik
  sollte immer von den spezifischen Daten und der Fragestellung
  abhängen, die beantwortet werden soll. Fortgeschrittene Techniken
  erweitern die Möglichkeiten von Matplotlib, erfordern aber auch ein
  tieferes Verständnis der Daten und der Visualisierungswerkzeuge.

*** 3D-Plotting
:PROPERTIES:
:CUSTOM_ID: 3d-plotting
:END:
Matplotlib bietet Funktionen für das 3D-Plotting, die es uns
ermöglichen, dreidimensionale Diagramme zu erstellen. Dies kann
besonders nützlich sein, wenn wir Daten mit mehr als zwei Dimensionen
visualisieren möchten.

Um ein 3D-Diagramm zu erstellen, müssen wir zunächst eine Instanz der
=Axes3D=-Klasse erstellen. Dies kann durch Hinzufügen des
Schlüsselwortarguments =projection='3d'= zur =add_subplot=-Methode
erreicht werden.

#+begin_src
import matplotlib.pyplot as plt
import numpy as np

fig = plt.figure()

# Erstellen einer 3D-Achse
ax = fig.add_subplot(111, projection='3d')

# Daten für 3D-Plot
z = np.linspace(0, 1, 100)
x = z * np.sin(25 * z)
y = z * np.cos(25 * z)

ax.plot(x, y, z)
plt.show()
#+end_src

*** Animationen
:PROPERTIES:
:CUSTOM_ID: animationen
:END:
Matplotlib bietet auch Unterstützung für animierte Diagramme. Mit der
=FuncAnimation=-Klasse können wir eine Funktion definieren, die bei
jedem Frame der Animation aufgerufen wird.

#+begin_src
import matplotlib.animation as animation

fig, ax = plt.subplots()

x = np.arange(0, 2*np.pi, 0.01)
line, = ax.plot(x, np.sin(x))

def animate(i):
    line.set_ydata(np.sin(x + i/50))  # update the data.
    return line,

ani = animation.FuncAnimation(
    fig, animate, interval=20, blit=True, save_count=50)

plt.show()
#+end_src

*** Subplots
:PROPERTIES:
:CUSTOM_ID: subplots
:END:
Mit Subplots können wir mehrere Diagramme in einer einzigen Figur
darstellen. Dies kann nützlich sein, wenn wir mehrere verwandte
Datenreihen haben, die wir vergleichen möchten.

#+begin_src
# Erstellen einer Figur und Subplots
fig, axs = plt.subplots(2)

# Daten für die Plots
x = np.linspace(0, 2 * np.pi, 400)
y1 = np.sin(x)
y2 = np.cos(x)

# Erstellen der Plots
axs[0].plot(x, y1)
axs[1].plot(x, y2)

plt.show()
#+end_src

** Komplexe Übungsaufgabe
:PROPERTIES:
:CUSTOM_ID: komplexe-übungsaufgabe
:END:

In dieser Aufgabe sollen Sie das bisher Gelernte anwenden, um
verschiedene Plots zu erstellen. Verwenden Sie dafür die Bibliotheken
Matplotlib und Numpy. Die Daten für einen der Plots befinden sich in
einer Datei =data.csv=, die Sie auf Moodle finden.

*** Teil 1: Sinus- und Cosinus-Plot
:PROPERTIES:
:CUSTOM_ID: teil-1-sinus--und-cosinus-plot
:END:
Erstellen Sie einen Plot mit den folgenden Anforderungen:

- Der Plot soll eine Sinus-Funktion im Bereich von 0 bis 10 darstellen.
- Der Plot soll eine Cosinus-Funktion im Bereich von 0 bis 10
  darstellen.
- Die Linie der Sinus-Funktion soll in der Farbe Rot dargestellt werden.
- Die Linie der Cosinus-Funktion soll in der Farbe Blau dargestellt
  werden.
- Der Plot soll einen Titel und Achsenbeschriftungen haben.
- Der Plot soll eine Legende enthalten.
- Der Plot soll angezeigt werden.

*** Teil 2: Histogramm
:PROPERTIES:
:CUSTOM_ID: teil-2-histogramm
:END:
Erstellen Sie einen Plot mit den folgenden Anforderungen:

- Der Plot soll eine zufällige Verteilung von 1000 Werten darstellen.
- Der Plot soll als Histogramm dargestellt werden.
- Der Plot soll 30 Bins enthalten.
- Der Plot soll in der Farbe Grün dargestellt werden.
- Der Plot soll einen Titel und Achsenbeschriftungen haben.
- Der Plot soll eine Legende enthalten.
- Der Plot soll angezeigt werden.

*** Teil 3: Scatter-Plot
:PROPERTIES:
:CUSTOM_ID: teil-3-scatter-plot
:END:
Erstellen Sie einen Plot mit den folgenden Anforderungen:

- Der Plot soll eine Verteilung von 100 Werten darstellen.
- Die Werte sollen aus einer externen Datei =data.csv= geladen werden.
- Der Plot soll als Scatter-Plot dargestellt werden.
- Die Punkte sollen in der Farbe Schwarz dargestellt werden.
- Die Punkte sollen eine Transparenz von 0.5 haben.
- Der Plot soll einen Titel und Achsenbeschriftungen haben.
- Der Plot soll eine Legende enthalten.
- Der Plot soll angezeigt werden.

*** Teil 4: Boxplot
:PROPERTIES:
:CUSTOM_ID: teil-4-boxplot
:END:
Erstellen Sie einen Plot mit den folgenden Anforderungen:

- Der Plot soll eine zufällige Verteilung von 1000 normalverteilten
  Werten darstellen.
- Der Plot soll als Boxplot dargestellt werden.
- Der Plot soll horizontale Boxen enthalten.
- Der Plot soll farbige Boxen enthalten.
- Der Plot soll einen Titel und Achsenbeschriftungen haben.
- Der Plot soll eine Legende enthalten.
- Der Plot soll angezeigt werden.

*** Teil 5: Gesamte Figure
:PROPERTIES:
:CUSTOM_ID: teil-5-gesamte-figure
:END:
Führen Sie alle vier Plots zu einer einzigen Figure zusammen und zeigen
Sie diese an.

*** Beispiellösung für die komplexe Übungsaufgabe
:PROPERTIES:
:CUSTOM_ID: beispiellösung-für-die-komplexe-übungsaufgabe
:END:
[[file:image.png]]



* Vorbreitungen
#+begin_src
; syntax: grammatik
; semantik: bedeutung

; ausgabe von Variablen
name = "Alice"
alter = 25
print("Name", name)
print("Alter:", alter)

; F-string formatierung
print(f"Name: {name}, Alter: {alter}")

; Eingabe
name = input("Wie heißt du? ")
print("Hallo", name)

; ueb 1
grusswort = input("geben Sie ein Grusswort")
name = input("wie heiszen Sie?")
print(grusswort, name)

; funktionsdefinition:
; parameter; Codeblock (Code); Rückgabe; Schlüsselwort

; arten von fehlern
; syntaxfehler; laufzeitfehler; indentationerror; nameerror;
; typeerror; indexerror

; dictionary
; a = {"alice": "1234",}; a.pop("alice"); a["alice"]
; new entry
; a["bob"] = "1234"

; operatoren: arithmetische Operatoren;
; + - / % **
; Vergleichsoperatoren;
; < > == != <= >=
; Logische Operatoren
; and or not
; identität und zugehörigkeitsoperatoren
; is; is not; in; not in

; achtung: a = [1,2,3]; c = [1,2,3] aber a is not c; denn die zwei List-Objekte
; verweisen auf nicht dieselbe Speicheraddresse


; programmverzweigungen
; if; if else; elif;
; match-case
alter = 20

match alter:
    case 0:
        print("Gerade geboren.")
    case 1 | 2 | 3:
        print("Kleinkind.")
    case 4 | 5 | 6:
        print("Vorschulkind.")
    case _ if 7 <= alter < 18:
        print("Jugendlicher.")
    case _:
        print("Erwachsener.")


; Praktische Übungen (Bestandsaufnahme 2)
bestand = {}
eingabe_name = ""

def üb_bestandsaufnahme():
    while True:
        eingabe_name = input("Bauteilname eingeben: ")
        if eingabe_name == "ENDE":
            break
        eingabe_anzahl = int(input(f"Anzahl von {eingabe_name} eingeben: "))
        bestand[eingabe_name] = eingabe_anzahl

; items Methode von Dictionarys
test  = {"A":1,"B":2}
for (key, value) in test.items():
  print(key,value)


def bauteil_bestand_zeigen(bestand):
    for (key, value) in bestand.items():
        print(f'{key}, {value}')

; range(start,stop,step)

def üb_maschinenauslastung4():
    max_pro_tag = int(input("max pro tag eingeben: "))
    list_auslastung = []
    for tag in range(5):
        tag_auslastung = int(input("produktionzahl eingeben: "))
        list_auslastung.append(tag_auslastung)
    list_auslastung_pro_tag = [ int(a / max_pro_tag * 100)  for a in list_auslastung ]
    wie_viele_teile_hätten_mehr_produziert = [ max_pro_tag - a for a in list_auslastung ]
    summe_der_woche = 0
    for i in tag_auslastung:
        summe_der_woche += i
    gesamt_auslastung_der_woche = int(summe_der_woche / (5 * max_pro_tag) * 100)

; fehlerhandhabung: try; except; finally
def fehlerhandhabung():
    try:
        zahl = int(input("Geben Sie eine Zahl ein:"))
        ergebnis = 10/zahl
        print("Ergebnis: ,", ergebnis)
    except ValueError:
        print("Das war keine gültige Zahl")
    except ZeroDivisionError:
        print("Fehler: Division durch Null ist nicht erlaubt")


; 3_io.org
; Fehlerbehandlung beim Dateizugriff
def fehlerbehandlung_beim_dateizugriff():
    try with open("beispiel.txt", "r") as file:
        content = file.read()
        print(content)
    except FileNotFoundError:
        print("Die Datei wurde nicht gefunden")
    return

def file_erstellen():
    file = open("file.txt", "w")
    file.write("hello world")
    file.close()
    return

def ueb_nicht_existierende_datei():
    try:
        file = open("nicht_existierte.datei", "r")
    except FileNotFoundError:
        print("file not found")
    finally:
        file.close()
    return

def ueb_komplexe_aufgabe():
    with open("input.txt", "r") as file:
        input_text = file.read()
        input_text.replace("Datei", "Text")
        with open("output.txt", "a") as ofile:
            ofile.write(input_text)
    return


; 4_algo
; bubble sort: einfach, ineffizient
; insertion sort: für kleine datensätze effizienter als bubble sort
; quicksort

; bubble sort mit Zeitkomplexität O(n^2); Speicherkomplexität O(1)
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # Optimierung: Wenn kein Tausch im inneren Loop, ist die Liste sortiert
        getauscht = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                # Tausche Elemente
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                getauscht = True
        if not getauscht:
            break
    return arr


; insertionsort; zeitkomplexität O(n^2); Speicherkomplexität O(1)
def insertion_sort(arr):
    for i in range(1, len(arr)):
        schluessel = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > schluessel:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = schluessel
    return arr


; suchalgorithmen
; lineare suche: einfach; ineffizient
; hash-basierte suche: effizient; aber zusätzliche datenstrukturen
; binäre suche: effizient, aber Daten müssen bereits sortiert sein

; lineare suche: Zeitkomp. O(n); Speicherkomp. O(1)
def lineare_suche(arr, x):
    for index, element in enumerate(arr):
        # print(f"Prüfe Index {index}: Wert {element}")
        if element == x:
            print(f"Element {x} gefunden an Position {index}")
            return index
    print(f"Element {x} nicht gefunden")
    return -1  # Element nicht gefunden


; binäre suche: zeitkomp O(nlogn); speicherkomp O(1)
def binaere_suche(arr, x):
    links, rechts = 0, len(arr) - 1
    while links <= rechts:
        mitte = (links + rechts) // 2
        # print(f"Suche zwischen Index {links} und {rechts}, Mitte: {mitte}")
        if arr[mitte] == x:
            print(f"Element {x} gefunden an Position {mitte}")
            return mitte
        elif arr[mitte] < x:
            links = mitte + 1
        else:
            rechts = mitte - 1
    print(f"Element {x} nicht gefunden")
    return -1  # Element nicht gefunden

; Pandas DataFrames: Zeilen als Einträge; Spalten haben vers. Datentyp
; (int, float, str)
import pandas as pd

def new_pandas():
    df = pd.DataFrame(data=[["Anna", 28, "Berlin"],
                        ["Ben", 32, "Hamburg"],
                        ["Chris", 25, "München"]], 
                  columns=["Name","Alter", "Stadt"])
    # aus einer liste von listen
    df = pd.DataFrame(data=[],columns=[])
    # aus einem dictionary
    df = {'Name': ['Tom', 'Nick', 'John'], 'Age': [20, 21, 19]}
    # aus csv
    df = pd.read_csv('file.csv')
    df = pd.DataFrame(data=[["Panda", 4, "Berlin"], ["Maus", 2, "Muenchen"]], columns=["Tier", "Alter", "Zoo"])
    # datenzugriff in dataframes
    # Auswahl einer Spalte durch loc
    # Erste Eintrag
    df.loc[0]
    df.loc[0, "Tier"]
    # Panda
    df.iloc[0,0]
    

    return df
#+end_src
